<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Image Detection</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #arView { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #gifOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; display: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
</head>
<body>
    <video id="arView" autoplay playsinline></video>
    <img id="gifOverlay" src="imgs/green-Gif.gif" alt="AR Animation">

    <script>
        const video = document.getElementById('arView');
        const gifOverlay = document.getElementById('gifOverlay');
        let model;
        let isDetecting = false;
        const triggerImage = new Image();
        triggerImage.src = 'imgs/FULA-TUP-Green.png';
        let triggerImageFeatures;

        async function init() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                video.srcObject = stream;

                model = await mobilenet.load();
                
                // Extract features from the trigger image
                triggerImageFeatures = await model.infer(triggerImage, true);

                detectImage();
            } catch (error) {
                console.error('Error initializing AR:', error);
            }
        }

        async function detectImage() {
            if (!isDetecting) {
                isDetecting = true;
                const videoFeatures = await model.infer(video, true);
                const similarity = cosineSimilarity(triggerImageFeatures, videoFeatures);

                if (similarity > 0.8) { // Adjust this threshold as needed
                    showGif();
                } else {
                    hideGif();
                }
                isDetecting = false;
            }

            requestAnimationFrame(detectImage);
        }

        function cosineSimilarity(tensorA, tensorB) {
            const a = tensorA.dataSync();
            const b = tensorB.dataSync();
            let sum = 0;
            let normA = 0;
            let normB = 0;
            for (let i = 0; i < a.length; i++) {
                sum += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            return sum / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        function showGif() {
            gifOverlay.style.display = 'block';
        }

        function hideGif() {
            gifOverlay.style.display = 'none';
        }

        function resizeOverlay() {
            const overlay = document.getElementById('gifOverlay');
            const aspectRatio = overlay.naturalWidth / overlay.naturalHeight;
            const screenAspectRatio = window.innerWidth / window.innerHeight;

            if (aspectRatio > screenAspectRatio) {
                overlay.style.width = '100%';
                overlay.style.height = 'auto';
            } else {
                overlay.style.width = 'auto';
                overlay.style.height = '100%';
            }
        }

        window.addEventListener('load', init);
        window.addEventListener('load', resizeOverlay);
        window.addEventListener('resize', resizeOverlay);
    </script>
</body>
</html>
