<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Image Detection</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #arView { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #gifOverlay { position: absolute; width: 100%; height: auto; max-width: 100%; object-fit: contain; display: none; left: 50%; transform: translateX(-50%); }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
</head>
<body>
    <video id="arView" autoplay playsinline></video>
    <img id="gifOverlay" src="imgs/Blue-Gif.gif" alt="AR Animation">

    <script>
        const video = document.getElementById('arView');
        const gifOverlay = document.getElementById('gifOverlay');
        let model, objectDetectionModel;
        let isDetecting = false;
        const triggerImage = new Image();
        triggerImage.src = 'imgs/FULA-TUP-Blue.jpg';
        let triggerImageFeatures;
        let isTargetImageDetected = false;
        let similarityBuffer = [];
        const bufferSize = 5;
        let frameCount = 0;
        const fullDetectionInterval = 30;

        async function init() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                video.srcObject = stream;

                model = await mobilenet.load();
                objectDetectionModel = await cocoSsd.load();
                
                triggerImageFeatures = await model.infer(triggerImage, true);

                detectImage();
            } catch (error) {
                console.error('Error initializing AR:', error);
            }
        }

        async function preprocessFrame(videoElement) {
            const canvas = document.createElement('canvas');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoElement, 0, 0);
            return tf.browser.fromPixels(canvas).div(255);
        }

        function updateSimilarityBuffer(similarity) {
            similarityBuffer.push(similarity);
            if (similarityBuffer.length > bufferSize) {
                similarityBuffer.shift();
            }
            return similarityBuffer.reduce((a, b) => a + b, 0) / similarityBuffer.length;
        }

        async function detectImage() {
            try {
                if (!isDetecting) {
                    isDetecting = true;
                    frameCount++;

                    if (frameCount % fullDetectionInterval === 0) {
                        const detectedObjects = await objectDetectionModel.detect(video);
                        const detectedRegion = getDetectedRegion(detectedObjects);
                        if (detectedRegion) {
                            showGif(detectedRegion);
                            isTargetImageDetected = true;
                        } else {
                            hideGif();
                            isTargetImageDetected = false;
                        }
                    } else {
                        const processedFrame = await preprocessFrame(video);
                        const videoFeatures = await model.infer(processedFrame, true);
                        const instantSimilarity = cosineSimilarity(triggerImageFeatures, videoFeatures);
                        const averageSimilarity = updateSimilarityBuffer(instantSimilarity);

                        if (averageSimilarity > 0.6) {
                            if (!isTargetImageDetected) {
                                const detectedObjects = await objectDetectionModel.detect(video);
                                const detectedRegion = getDetectedRegion(detectedObjects);
                                if (detectedRegion) {
                                    showGif(detectedRegion);
                                    isTargetImageDetected = true;
                                }
                            }
                        } else {
                            if (isTargetImageDetected) {
                                hideGif();
                                isTargetImageDetected = false;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error in detection:', error);
            } finally {
                isDetecting = false;
                requestAnimationFrame(detectImage);
            }
        }

        function getDetectedRegion(detectedObjects) {
            const detectedObject = detectedObjects.reduce((prev, current) => 
                (prev.score > current.score) ? prev : current
            );

            if (detectedObject) {
                return {
                    x: detectedObject.bbox[0],
                    y: detectedObject.bbox[1],
                    width: detectedObject.bbox[2],
                    height: detectedObject.bbox[3]
                };
            }
            return null;
        }

        function cosineSimilarity(tensorA, tensorB) {
            const a = tensorA.dataSync();
            const b = tensorB.dataSync();
            let sum = 0;
            let normA = 0;
            let normB = 0;
            for (let i = 0; i < a.length; i++) {
                sum += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            return sum / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        function showGif(region) {
            gifOverlay.style.display = 'block';
            gifOverlay.style.top = `${region.y + (region.height / 2) - (gifOverlay.offsetHeight / 2)}px`;
            gifOverlay.style.width = `${region.width}px`;
            gifOverlay.style.height = 'auto';
            resetGif();
        }

        function hideGif() {
            gifOverlay.style.display = 'none';
        }

        function resetGif() {
            gifOverlay.src = gifOverlay.src;
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
